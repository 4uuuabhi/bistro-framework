using System;
using System.Collections.Generic;
using System.Xml;
using System.ComponentModel;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using Bistro.DesignerInterfaces;

namespace Bistro.Designer.Explorer
{
    /// <summary>
    /// Base object for all objects to be represented in the workflow explorer
    /// </summary>
    /// <remarks>
    /// Within the main domain of the Visual Studio instances of the classes derived from the
    /// <see cref="AbstractNode"/> class carry data to be displayed in the Workflow Explorer tree. <br/>
    /// Initially only top level nodes of the tree for the application are created. If the user expands the
    /// tree node associated with the <see cref="AbstractNode"/> the node builds the list of its children 
    /// using <see cref="M:GetChildren()"/> method. In the AbstractNode class itself this method returns 
    /// and empty list. The overrides of this method in derived classes provide the actual list as
    /// necessary for a particular node type.<br/>
    /// For some node types the <see cref="M:GetChildren()"/> method should generate the list based on the 
    /// application definition. This information should be retrieved from the application definition 
    /// objects which exist in the Application Definition domain. (<see cref="ApplicationProxy" /> for more 
    /// information on the Application Definition domains). <br/>The <see cref="M:GetChildrenExternal()"/> should
    /// be used to request such information. When this method is called on a node, the node is serialized and sent
    /// to the Application Definition domain, where the <see cref="ApplicationWrapper"/> object calls on the 
    /// serialized node the <see cref="M:GetChildren(ApplicationWrapper application)"/> method. Within this 
    /// method the information from the serialized node can be used to access necessary information from
    /// the application definition through the provided <see cref="ApplicationWrapper"/> object. The list
    /// generated by the method is serialized and sent back to the main Visual Studio domain.<br/>
    /// After the list is recieved in the main domain it has to be built into existing tree by calling
    /// <see cref="M:AttachChildren()"/> and <see cref="M:AttachToParent()"/> methods.
    /// <br/>As the workflow explorer nodes are painted, the instances of the <see cref="TreeNode"/> classes 
    /// are dynamically created to represent them in the Workflow Explorer user interface.
    /// </remarks>
    [Serializable]
    [ComVisible(true)]
    public abstract class ExplorerNode : IEnumerable<ExplorerNode>, IDisposable, IComparer<ExplorerNode>
    {
        #region Constants

        protected const string ACTION_ICON = "Action.bmp";
        protected const string ACTIVITY_ICON = "Activity.bmp";
        protected const string ACTIVITIES_ICON = "Activities.bmp";
        protected const string APPLICATION_ICON = "Application.bmp";
        protected const string BINDERS_ICON = "Binders.bmp";
        protected const string DOCUMENTS_ICON = "Documents.bmp";
        protected const string GLOBALBINDER_ICON = "Binder.bmp";
        protected const string FACTORY_ICON = "Document.bmp";
        protected const string FIELD_ICON = "Field.bmp";
        protected const string FOLDER_ICON = "Folder.bmp";
        protected const string LINK_ICON = "Link.bmp";
        protected const string SESSIONBINDER_ICON = "Binder.bmp";
        protected const string USERPROFILEBINDER_ICON = "Binder.bmp";
        protected const string ERROR_ICON = "Error.bmp";
        protected const string OPEN_FOLDER_ICON = "OpenFolder.bmp";
        protected const string OPEN_FOLDER_YELLOW_ICON = "OpenFolderYellow.bmp";
        protected const string RESOURCE_ICON = "Resource.bmp";
        protected const string RESOURCE_CONSUMER_ICON = "ResourceConsumer.bmp";
        protected const string RESOURCE_PROVIDER_ICON = "ResourceProvider.bmp";

        #endregion

        #region Fields

        [NonSerialized]
        IBsApplicationDesigner application;

        [NonSerialized]
        ExplorerNode root;

        [NonSerialized]
        TreeNode treeNode;

        [NonSerialized]
        bool retrieved = false;

        [NonSerialized]
        private ExplorerNode parent;

        //[NonSerialized]
        //private Dictionary<XmlNode, XmlTextNode> definitions;

        private int position = -1;
        private string fileName;

        private string imageKey;
        private string expandedImageKey;

        private Dictionary<string, ExplorerNode> children = new Dictionary<string, ExplorerNode>();
        private string name;
        private string caption;

        #endregion

        #region Constructors

        protected ExplorerNode(IBsApplicationDesigner application, string name, string imageKey)
            : this((ExplorerNode)null, name, imageKey)
        {
            this.application = application;
        }

        protected ExplorerNode(ExplorerNode parent, string name, string imageKey)
            : this(parent, name, imageKey, null)
        {
        }

        protected ExplorerNode(ExplorerNode parent, string name, string imageKey, string expandedImageKey)
        {
            this.name = name;
            caption = name;
            this.imageKey = imageKey;
            this.expandedImageKey = expandedImageKey;
            this.parent = parent;

            if (parent == null)
                root = this;
            else
            {
                root = parent.root;
                application = parent.application;
                parent.children[this.name] = this;
                parent.retrieved = false;
            }

        }

        /// <summary>
        /// cloning constructor
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="source"></param>
        public ExplorerNode(ExplorerNode parent, ExplorerNode source, string imageKey, string expandedImageKey)
            : this(parent, source.name, imageKey, expandedImageKey)
        {
            clonedFrom = source;
        }
        private ExplorerNode clonedFrom;
        public ExplorerNode ClonedFrom { get { return clonedFrom; } }

        public virtual void Adopt(ExplorerNode node, string newName)
        {
            if (node.parent != null)
                node.parent.children.Remove(node.name);

            node.name = newName;
            node.caption = newName;

            node.parent = this;
            children[node.name] = node;

            node.RemoveAvatar();
        }

        #endregion

        #region Public properties for display in the property window

        /// <summary>
        /// Gets or Sets the Name for the node - unique name among siblings
        /// </summary>
        /// <value>The name.</value>
        public virtual string Name
        {
            get { return name; }
            protected set
            {
                if (value == null || null == parent || name == value)
                    return;

                parent.children.Remove(name);
                name = value;

                parent.children[name] = this;
                if (treeNode != null)
                {
                    treeNode.Name = value;
                    treeNode.Text = Caption;
                }
            }
        }

        #endregion

        #region Properties controlling how the node is displayed in the tree

        /// <summary>
        /// Gets the Caption for the node.
        /// </summary>
        /// <value>The caption.</value>
        [Browsable(false)]
        public virtual string Caption { get { return caption; } }

        /// <summary>
        /// Gets the index of the image representing the node in the workflow explorer in the collapsed state
        /// </summary>
        /// <value>The index of the image.</value>
        protected string ImageKey { get { return imageKey; } }

        /// <summary>
        /// Gets the index of the image representing the node in the workflow explorer in the expanded state
        /// </summary>
        /// <value>The index of the selected image.</value>
        protected string ExpandedImageKey { get { return expandedImageKey; } }

        protected virtual bool Expandable() { return false; }

        /// <summary>
        /// Gets a value indicating whether this node can be dragged onto the designer surface.
        /// </summary>
        /// <value>
        /// 	<c>true</c> if this instance is draggable; otherwise, <c>false</c>.
        /// </value>
        [Browsable(false)]
        public virtual bool IsDraggable { get { return true; } }

        #endregion

        #region Internal properties

        /// <summary>
        /// Gets the Parent node for this object.
        /// </summary>
        /// <value>The parent.</value>
        [Browsable(false)]
        public ExplorerNode Parent { get { return parent; } }

        /// <summary>
        /// Gets the application proxy object.
        /// </summary>
        /// <value>The application proxy.</value>
        [Browsable(false)]
        public virtual IBsApplicationDesigner Application { get { return application; } }

        internal int SourceLocation { get { return position; } }

        protected bool IsRetireved { get { return retrieved; } }

        /// <summary>
        /// Gets the <see cref="T:ExplorerNode"/> with the specified name from the list of immediate children.
        /// </summary>
        /// <value></value>
        /// <remarks>
        /// the node is expanded first to make sure that the list of children has real children, 
        /// not the <see cref="T:ReferenceNode"/> placeholder<br/>
        /// The associated TreeNode is not expanded
        /// </remarks>
        public ExplorerNode this[string name]
        {
            get
            {
                Expand();
                ExplorerNode result = null;
                children.TryGetValue(name, out result);
                return result;
            }
        }

        [Browsable(false)]
        public ExplorerNode Root { get { return root; } }

        /// <summary>
        /// The nodes which return <b>true</b> will be removed when the last child is removed
        /// </summary>
        protected virtual bool IsRemovable { get { return false; } }

        protected IWsExplorer Explorer { get { return (IWsExplorer)application.GetService(typeof(SWsExplorer)); } }

        [Browsable(false)]
        public string FileName { get { return fileName; } }

        #endregion

        #region Children manipulation

        /// <summary>
        /// Expands the field node requesting the tree of child nodes for the specified node.
        /// </summary>        
        /// <returns>Returns <b>true</b> if the new child nodes were added and the node has to be repainted</returns>
        protected virtual bool Expand()
        {
            if (retrieved)
                return false;
            retrieved = true;

            foreach (ExplorerNode child in GetChildren())
                AttachChild(child);
            return true;

        }

        /// <summary>
        /// Attaches this node (and its children) to a new parent.
        /// </summary>
        /// <param name="parent">The parent.</param>
        public void AttachChild(ExplorerNode child)
        {
            child.parent = this;
            child.root = root;
            child.application = application;
            if (!children.ContainsKey(child.name))
                children[child.name] = child;
            child.FixupChildren();
        }

        public void FixupChildren()
        {
            foreach (ExplorerNode child in this)
                AttachChild(child);
        }

        /// <summary>
        /// Builds a list of children for the node.
        /// </summary>
        /// <returns></returns>
        protected virtual IEnumerable<ExplorerNode> GetChildren() { return new List<ExplorerNode>(); }

        /// <summary>
        /// Interfaces with the Application Proxy to retrieve the children from the Application Definition domain.
        /// </summary>
        /// <returns></returns>
        protected IEnumerable<ExplorerNode> GetChildrenExternal()
        {
            IEnumerable<ExplorerNode> list = application.GetChildrenForNode(this);
            return list;
        }

        public virtual IEnumerable<ExplorerNode> GetChildren(IBsApplicationWrapper application) { return new List<ExplorerNode>(); }

        /// <summary>
        /// Removes all children.
        /// </summary>
        protected internal void ClearChildren()
        {
            if (treeNode != null && treeNode.TreeView != null && !treeNode.TreeView.IsDisposed && treeNode.TreeView.InvokeRequired)
            {
                treeNode.TreeView.Invoke(new MethodInvoker(ClearChildren));
                return;
            }

            foreach (ExplorerNode child in new List<ExplorerNode>(children.Values))
                child.Dispose();
            retrieved = false;

            if (
                treeNode != null
                && treeNode.TreeView != null
                && !treeNode.TreeView.IsDisposed
                && Expandable()
                )
            {
                treeNode.Nodes.Add("...", "...");
                treeNode.Collapse();
            }
        }

        #endregion

        delegate void PaintDelegate(TreeView treeView);

        /// <summary>
        /// Paints the node in the specified tree view.
        /// </summary>
        /// <param name="treeView">The tree view.</param>
        /// <returns></returns>
        public void Paint(TreeView treeView)
        {
            if (treeView.InvokeRequired)
                treeView.Invoke(new PaintDelegate(Paint), treeView);
            else
            {
                TreeNodeCollection treeNodeCollection = treeView.Nodes;
                if (parent != null)
                {
                    TreeNode node = parent.FindTreeNode(treeView);
                    if (node != null)
                        treeNodeCollection = node.Nodes;
                }

                treeView.BeginUpdate();
                InternalPaint(treeNodeCollection);
                treeView.EndUpdate();
            }
        }

        public void Paint()
        {
            if (Application != null)
            {
                IWsExplorer explorer = (IWsExplorer)Application.GetService(typeof(SWsExplorer));
                if (explorer != null)
                    explorer.PaintTreeNode(this);
            }
        }

        /// <summary>
        /// Looks up the <see cref="T:TreeNode"/> instance this abstract node is bound to.
        /// </summary>
        /// <param name="treeView">The tree view to locate the bound tree node.</param>
        /// <returns></returns>
        /// <remarks>To find a tree node we are looking for a tree node with the name identical
        /// to the name of our explorer node. This process starts from the top node and recursively 
        /// drills down</remarks>
        private TreeNode FindTreeNode(TreeView treeView)
        {
            if (parent == null)
                return treeView.Nodes[name];

            TreeNode parentNode = parent.FindTreeNode(treeView);
            if (parentNode != null)
                return parentNode.Nodes[name];

            return null;
        }

        /// <summary>
        /// Paints the node in the specified tree view.
        /// </summary>
        /// <param name="treeNodeCollection">The tree node collection.</param>
        /// <returns></returns>
        private void InternalPaint(TreeNodeCollection treeNodeCollection)
        {
            if (!treeNodeCollection.ContainsKey(name))
            {
                treeNode = new TreeNode();
                treeNode.Name = name;
                if (Expandable() && !retrieved)
                    treeNode.Nodes.Add("...", "...");

                // add the node in the tree node collection in sort order
                int i = 0;
                for (; i < treeNodeCollection.Count; i++)
                    if (treeNodeCollection[i].Tag != null && Parent != null && Parent.Compare(treeNodeCollection[i].Tag as ExplorerNode, this) > 0)
                        break;
                treeNodeCollection.Insert(i, treeNode);
            }
            else
                treeNode = treeNodeCollection[name];

            InitializeTreeNode(treeNode);

            foreach (ExplorerNode child in this)
                child.InternalPaint(treeNode.Nodes);

        }

        public void SetSelected()
        {
            Explorer.SetSelected(this);
        }

        /// <summary>
        /// Initializes the tree node representing the <see cref="AbstractNode"/> in the Workflow Explorer UI
        /// </summary>
        /// <param name="treeNode">The tree node.</param>
        protected virtual void InitializeTreeNode(TreeNode treeNode)
        {
            treeNode.Text = Caption;
            treeNode.ImageKey = ImageKey;
            treeNode.SelectedImageKey = ImageKey;
            treeNode.Tag = this;
            treeNode.ContextMenuStrip = GetContextMenu(new ContextMenuStrip());
        }

        #region Methods managing the context menus
      
        protected virtual ContextMenuStrip GetContextMenu(ContextMenuStrip contextMenu)
        {
            if (null == contextMenu)
                return null;
            contextMenu.Items.Add(new ToolStripMenuItem("Properties", null, new EventHandler(ShowProperties), "Properties"));
            contextMenu.Items.Add(new ToolStripMenuItem("Show Source", null, new EventHandler(ShowSource), "ShowSource"));

            return contextMenu;
        }

        /// <summary>
        /// Shows the properties.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="args">The <see cref="System.EventArgs"/> instance containing the event data.</param>
        protected virtual void ShowProperties(object sender, EventArgs args)
        {
            MessageBox.Show("Property Windows");
            //Explorer.SetSelected(this);
            //application.ShowPropertiesWindow();
        }

        protected virtual void ShowSource(object sender, EventArgs args)
        {
            MessageBox.Show("Source Windows");
            //application.ShowSource(fileName, position);
        }

        //protected virtual void BuildAccessPath(XmlNode definition)
        //{
        //    BuildAccessPath(new ConfigObject(null, definition));
        //}

        //protected virtual void BuildAccessPath(IConfigObject configObject)
        //{
        //    fileName = Utilities.GetConfigFilepath(configObject);
        //    ExplorerNode parent = this.parent;

        //    bool found = false;
        //    while (parent != null)
        //    {
        //        if (parent.fileName == null)
        //        {
        //            parent = parent.parent;
        //            continue;
        //        }
        //        if (parent.fileName == fileName)
        //            found = true;
        //        break;
        //    }
        //    if (found)
        //        definitions = parent.definitions;
        //    else
        //        definitions = Utilities.GetSourceNodes(configObject);

        //    position = Utilities.GetSourceOffset(definitions, configObject);
        //}

        #endregion

        #region IEnumerable<AbstractNode> Members

        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<ExplorerNode> GetEnumerator()
        {
            return children.Values.GetEnumerator();
        }

        #endregion

        #region IEnumerable Members

        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
        /// </returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return children.Values.GetEnumerator();
        }

        #endregion

        #region Event Handlers

        public void BeforeLabelEdit(object sender, NodeLabelEditEventArgs e)
        {
            e.CancelEdit = !CanEditLabel((ExplorerNode)e.Node.Tag);
        }

        protected virtual bool CanEditLabel(ExplorerNode node) { return false; }

        public void AfterLabelEdit(object sender, NodeLabelEditEventArgs e)
        {
            EditLabel((ExplorerNode)e.Node.Tag, e.Label);
        }

        protected virtual void EditLabel(ExplorerNode abstractNode, string label) { }

        public void AfterExpand(object sender, TreeViewEventArgs e)
        {
            if (expandedImageKey == null)
                return;
            e.Node.ImageKey = expandedImageKey;
            e.Node.SelectedImageKey = expandedImageKey;
        }

        public void AfterCollapse(object sender, TreeViewEventArgs e)
        {
            e.Node.ImageKey = imageKey;
            e.Node.SelectedImageKey = imageKey;
        }

        /// <summary>
        /// BeforeExpand event handler. Handles expanding of the corresponding node in the treeview 
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="T:System.Windows.Forms.TreeViewCancelEventArgs"/> instance containing the event data.</param>
        public void BeforeExpand(object sender, TreeViewCancelEventArgs e)
        {
            if (!Expand())
                return;
            Paint(e.Node.TreeView);
            e.Node.Nodes.RemoveByKey("...");
        }

        public virtual void DoubleClick(object sender, MouseEventArgs e)
        {
            ShowSource(sender, e);
        }

        #endregion

        #region IDisposable

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        // Implements IDisposable.
        // Do not make this method virtual.
        // A derived class should not be able to override this method.
        {
            Dispose(true);
            // This object will be cleaned up by the Dispose method.
            // Therefore, you should call GC.SupressFinalize to
            // take this object off the finalization queue 
            // and prevent finalization code for this object
            // from executing a second time.
            //           GC.SuppressFinalize(this);
        }

        // Dispose(bool disposing) executes in two distinct scenarios.
        // If disposing equals true, the method has been called directly
        // or indirectly by a user's code. Managed and unmanaged resources
        // can be disposed.
        // If disposing equals false, the method has been called by the 
        // runtime from inside the finalizer and you should not reference 
        // other objects. Only unmanaged resources can be disposed.
        private bool disposed = false;
        /// <summary>
        /// Releases the unmanaged resources used by the <see cref="Activity"/> and optionally releases the managed resources.
        /// </summary>
        /// <param name="disposing"><b>true</b> to release both managed and unmanaged resources; <b>false</b> to release only unmanaged resources. 
        /// </param>
        private void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            lock (this)
            {
                if (this.disposed)
                    return;
                disposed = true;
            }

            // If disposing equals true, dispose all managed 
            // and unmanaged resources.
            if (disposing)
                DisposeManaged();

            // Call the appropriate methods to clean up 
            // unmanaged resources here.
            // If disposing is false, 
            // only the following code is executed.
            DisposeUnmanaged();
        }

        /// <summary>
        /// Disposes of the managed resources.
        /// </summary>
        /// <remarks> When overriding this method make sure to call the base DisposeManaged <b>after</b> 
        /// disposing of your resources</remarks>
        protected virtual void DisposeManaged()
        {
            RemoveAvatar();

            List<ExplorerNode> children = new List<ExplorerNode>(this.children.Values);
            this.children.Clear();
            foreach (ExplorerNode child in children)
                child.Dispose();

            if (parent != null)
            {
                parent.RemoveChild(this);
                if (parent.children.Count == 0 && parent.IsRemovable)
                    parent.Dispose();
            }
        }

        protected virtual void RemoveChild(ExplorerNode child)
        {
            children.Remove(child.name);
        }

        protected virtual void DisposeUnmanaged()
        {
        }

        private void RemoveAvatar()
        {
            if (treeNode == null || treeNode.TreeView == null || treeNode.TreeView.IsDisposed)
                return;

            TreeView treeView = treeNode.TreeView;

            if (treeView.InvokeRequired)
                treeView.Invoke(new MethodInvoker(RemoveAvatar));
            else
            {
                treeNode.Remove();
                treeNode = null;
            }

        }

        public TreeNode TreeNode { get { return treeNode; } }

        #endregion

        #region IComparer<ExplorerNode> Members

        public virtual int Compare(ExplorerNode x, ExplorerNode y)
        {
            return string.Compare(x.name, y.name);
        }

        #endregion
    }     
}
